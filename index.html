<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cheer 8-Count Planner</title>
  <style>
    :root {
      --accent: #ff6b6b;
      --accent-dark: #d64545;
      --bg: #f5f7fb;
      --grid-border: #d0d5dd;
      --text: #1f2937;
      --muted: #6b7280;
      --row-highlight: rgba(255, 107, 107, 0.12);
      --cell-highlight: rgba(255, 107, 107, 0.2);
      --inactive: rgba(148, 163, 184, 0.35);
      color-scheme: light dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0 0 12px 0;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      max-width: 1200px;
      margin: 0 auto;
      width: 100%;
      padding: 16px;
      gap: 12px;
    }

    .control-panel {
      background: #ffffff;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
      display: flex;
      flex-wrap: wrap;
      gap: 12px 16px;
      align-items: flex-end;
    }

    .control-panel label {
      font-size: 0.85rem;
      font-weight: 600;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .control-panel input[type="number"],
    .control-panel input[type="text"] {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--grid-border);
      min-width: 90px;
      font-size: 0.95rem;
    }

    .control-panel input[type="file"] {
      font-size: 0.9rem;
    }

    button {
      padding: 8px 14px;
      border-radius: 8px;
      border: 1px solid transparent;
      background: var(--accent);
      color: #fff;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    button.secondary {
      background: transparent;
      color: var(--text);
      border-color: var(--grid-border);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
      background: var(--accent-dark);
    }

    .toggle-button {
      min-width: 140px;
    }

    .toggle-button.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    .toggle-button.active:hover {
      background: var(--accent-dark);
    }

    .playback-buttons {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .hint {
      margin: 4px 0 0 4px;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .timeline-wrapper {
      background: #ffffff;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
    }

    .timeline {
      width: 100%;
      height: 164px;
      background: linear-gradient(180deg, #0f172a 0%, #1f2937 100%);
      border-radius: 12px;
      position: relative;
      cursor: pointer;
      overflow: hidden;
      touch-action: none;
    }

    .timeline canvas {
      display: block;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .timeline .fill {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      background: rgba(255, 107, 107, 0.16);
      pointer-events: none;
      width: 0;
    }

    .timeline .cursor {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--accent);
      transform: translateX(-1px);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.15);
      pointer-events: none;
    }

    .timeline .cursor::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid var(--accent);
      background: #fff;
      transform: translate(-50%, -50%);
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.2);
    }

    .grid-container {
      flex: 1;
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
      overflow: auto;
      position: relative;
    }

    .intro-row th {
      background: #e2e8f0;
      color: var(--muted);
      font-weight: 600;
    }

    .intro-cell {
      background: rgba(148, 163, 184, 0.25);
      color: var(--muted);
      font-weight: 600;
      text-align: center;
    }

    .intro-cell.is-placeholder {
      background: rgba(148, 163, 184, 0.12);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }

    thead th {
      position: sticky;
      top: 0;
      background: #fafbff;
      z-index: 2;
      border-bottom: 1px solid var(--grid-border);
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      padding: 10px 6px;
      color: var(--muted);
    }

    tbody th {
      background: #f8fafc;
      font-weight: 600;
      color: var(--muted);
      border-right: 1px solid var(--grid-border);
      width: 54px;
      min-width: 54px;
      text-align: center;
      padding: 8px 4px;
      position: sticky;
      left: 0;
      z-index: 1;
    }

    td {
      border: 1px solid var(--grid-border);
      padding: 8px 6px;
      min-height: 42px;
      font-size: 0.95rem;
      line-height: 1.35;
      vertical-align: top;
      word-break: break-word;
      background: #fff;
    }

    td.beat-cell {
      cursor: text;
      position: relative;
    }

    td[data-inactive="true"] {
      background: rgba(241, 245, 249, 0.8);
      color: var(--muted);
    }

    td.intro-cell[data-inactive="true"] {
      background: rgba(148, 163, 184, 0.25);
    }

    td.intro-cell.is-placeholder {
      background: rgba(148, 163, 184, 0.12);
    }

    td.beat-cell[data-count]::before {
      content: attr(data-count);
      position: absolute;
      top: 4px;
      right: 6px;
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--muted);
      pointer-events: none;
    }

    tr.is-current td,
    tr.is-current th {
      background: var(--row-highlight);
    }

    td.is-current {
      background: var(--cell-highlight);
      border: 3px solid var(--accent);
    }

    td.beat-cell:focus {
      outline: 2px solid var(--accent);
      outline-offset: -2px;
    }

    .status-bar {
      display: flex;
      gap: 16px;
      justify-content: flex-end;
      font-size: 0.85rem;
      color: var(--muted);
      margin-top: 8px;
    }

    @media (max-width: 768px) {
      main {
        padding: 12px;
      }

      .control-panel {
        flex-direction: column;
        align-items: stretch;
      }

      button,
      .control-panel input[type="number"],
      .control-panel input[type="text"] {
        width: 100%;
      }

      tbody th {
        position: sticky;
        left: auto;
      }
    }
  </style>
</head>
<body>
  <main>
    <section class="control-panel" aria-label="Playback and configuration controls">
      <div style="flex: 1 1 100%; min-width: 250px;">
        <h1>Cheer 8-Count Planner</h1>
      </div>
      <label for="track-file">Audio Track
        <input type="file" id="track-file" accept="audio/*">
      </label>
      <label for="track-label">Track Label
        <input type="text" id="track-label" placeholder="Optional name for autosave key">
      </label>
      <label for="bpm-input">BPM
        <input type="number" id="bpm-input" min="1" step="1" value="144">
      </label>
      <label for="offset-input">Offset (sec)
        <input type="number" id="offset-input" step="0.01" value="0">
      </label>
      <label for="intro-offset-input">Intro Offset (beats)
        <input type="number" id="intro-offset-input" step="0.01" value="0">
      </label>
      <button id="rebuild-grid" class="secondary" type="button">Rebuild Grid</button>
      <div class="playback-buttons">
        <button id="play-btn" type="button">Play</button>
        <button id="pause-btn" type="button">Pause</button>
        <button id="back-phrase" type="button">&laquo; 8-count</button>
        <button id="forward-phrase" type="button">8-count &raquo;</button>
        <button id="click-toggle" type="button" class="secondary toggle-button" aria-pressed="false">Click Track: Off</button>
      </div>
      <div class="playback-buttons">
        <button id="export-json" type="button" class="secondary">Export JSON</button>
        <button id="export-csv" type="button" class="secondary">Export CSV</button>
        <button id="import-json" type="button" class="secondary">Import JSON</button>
      </div>
      <div class="playback-buttons">
        <button id="auto-detect-btn" type="button">Auto-Detect BPM</button>
        <button id="tap-tempo-btn" type="button" class="secondary">Tap Tempo</button>
        <button id="anchor-current-btn" type="button" class="secondary">Anchor Current Beat</button>
        <button id="clear-anchors-btn" type="button" class="secondary">Clear Anchors</button>
      </div>
      <p class="hint">Cmd/Ctrl+click a beat cell to anchor it at the current audio time.</p>
    </section>

    <section class="timeline-wrapper" aria-label="Timeline seek bar">
      <div class="timeline" id="timeline">
        <canvas id="waveform-canvas" aria-hidden="true"></canvas>
        <div class="fill" id="timeline-fill"></div>
        <div class="cursor" id="timeline-cursor" role="presentation"></div>
      </div>
      <div class="status-bar" id="status-bar">
        <span id="status-time">0:00 / 0:00</span>
        <span id="status-beat">Beat 0 (Phrase 0)</span>
        <span id="status-detect">Manual BPM</span>
      </div>
    </section>

    <section class="grid-container" aria-label="8-count note grid">
      <table id="count-grid">
        <thead>
          <tr>
            <th scope="col">Phrase</th>
            <th scope="col">1</th>
            <th scope="col">2</th>
            <th scope="col">3</th>
            <th scope="col">4</th>
            <th scope="col">5</th>
            <th scope="col">6</th>
            <th scope="col">7</th>
            <th scope="col">8</th>
          </tr>
        </thead>
        <tbody id="grid-body"></tbody>
      </table>
    </section>
  </main>

  <audio id="planner-audio" preload="metadata"></audio>
  <input type="file" id="import-json-input" accept="application/json" hidden>

  <script>
    (() => {
      'use strict';

      const audio = document.getElementById('planner-audio');
      const gridBody = document.getElementById('grid-body');
      const gridContainer = document.querySelector('.grid-container');
      const bpmInput = document.getElementById('bpm-input');
      const offsetInput = document.getElementById('offset-input');
      const introOffsetInput = document.getElementById('intro-offset-input');
      const trackFileInput = document.getElementById('track-file');
      const trackLabelInput = document.getElementById('track-label');
      const rebuildButton = document.getElementById('rebuild-grid');
      const playButton = document.getElementById('play-btn');
      const pauseButton = document.getElementById('pause-btn');
      const backwardButton = document.getElementById('back-phrase');
      const forwardButton = document.getElementById('forward-phrase');
      const clickToggleButton = document.getElementById('click-toggle');
      const exportJsonButton = document.getElementById('export-json');
      const exportCsvButton = document.getElementById('export-csv');
      const importJsonButton = document.getElementById('import-json');
      const autoDetectButton = document.getElementById('auto-detect-btn');
      const tapTempoButton = document.getElementById('tap-tempo-btn');
      const anchorCurrentButton = document.getElementById('anchor-current-btn');
      const clearAnchorsButton = document.getElementById('clear-anchors-btn');
      const importJsonInput = document.getElementById('import-json-input');
      const timeline = document.getElementById('timeline');
      const timelineFill = document.getElementById('timeline-fill');
      const timelineCursor = document.getElementById('timeline-cursor');
      const waveformCanvas = document.getElementById('waveform-canvas');
      const statusTime = document.getElementById('status-time');
      const statusBeat = document.getElementById('status-beat');
      const statusDetect = document.getElementById('status-detect');

      const hasAudioContext = typeof window.AudioContext === 'function' || typeof window.webkitAudioContext === 'function';

      const storageAvailable = (() => {
        try {
          const key = '__cheer-storage-test';
          window.localStorage.setItem(key, '1');
          window.localStorage.removeItem(key);
          return true;
        } catch (err) {
          console.warn('LocalStorage unavailable', err);
          return false;
        }
      })();

      // Central app state shared across UI handlers and the render loop.
      const state = {
        bpm: Number.parseInt(bpmInput.value, 10) || 144,
        offset: Number.parseFloat(offsetInput.value) || 0,
        introOffsetBeats: Number.parseFloat(introOffsetInput.value) || 0,
        beatDuration: 60 / (Number.parseInt(bpmInput.value, 10) || 144),
        totalBeats: 0,
        gridBeatCount: 0,
        trackId: '',
        trackFileName: '',
        objectUrl: null,
        phraseData: [],
        rafId: null,
        cellIndexMap: new Map(),
        currentCell: null,
        currentRow: null,
        lastHighlightBeat: null,
        pendingImport: null,
        clickTrackEnabled: false,
        audioContext: null,
        baseBeatTimes: null,
        finalBeatTimes: null,
        anchors: [],
        detectionInfo: { method: 'manual', confidence: null, source: 'manual' },
        tapTempoHistory: [],
        tapTempoResetId: null,
        autoDetecting: false,
        analysisCache: null,
        gridStartBeat: 0,
        pendingBeats: null,
        pendingAnchors: null,
        pendingDetectionInfo: null,
        pendingIntroOffsetBeats: null,
        waveformPeaks: null,
        waveformPeakCount: 0,
        waveformDuration: 0,
        waveformLoading: null,
        savedTrackInfo: null,
        pendingTrackFileName: null,
        pendingTrackDuration: null,
        introNotes: [],
        pendingIntroNotes: null,
      };

      function updateTrackId() {
        const customLabel = trackLabelInput.value.trim();
        const fallback = state.trackFileName || 'untitled-track';
        state.trackId = customLabel || fallback;
      }

      function parseSettingsFromInputs() {
        const bpmVal = Number.parseInt(bpmInput.value, 10);
        const offsetVal = Number.parseFloat(offsetInput.value);
        const introBeatsVal = Number.parseFloat(introOffsetInput.value);
        state.bpm = Number.isFinite(bpmVal) && bpmVal > 0 ? bpmVal : 144;
        state.offset = Number.isFinite(offsetVal) ? offsetVal : 0;
        state.introOffsetBeats = Number.isFinite(introBeatsVal) ? Math.max(0, introBeatsVal) : 0;
        state.beatDuration = 60 / state.bpm;
        updateGridStartBeat(state.totalBeats);
        updateTrackId();
      }

      function getStorageKey() {
        if (!storageAvailable || !state.trackId) return null;
        return `cheer-8-count::${state.trackId}::${state.bpm}::${state.offset}::${state.introOffsetBeats}`;
      }

      function ensurePhraseDataSize(targetPhrases) {
        if (state.phraseData.length < targetPhrases) {
          for (let i = state.phraseData.length; i < targetPhrases; i += 1) {
            state.phraseData.push(Array(8).fill(''));
          }
        }
      }

      function ensureIntroNotesSize(targetBeats) {
        if (!Array.isArray(state.introNotes)) {
          state.introNotes = [];
        }
        if (state.introNotes.length > targetBeats) {
          state.introNotes.length = targetBeats;
        } else {
          while (state.introNotes.length < targetBeats) {
            state.introNotes.push('');
          }
        }
      }

      function ensureAudioContext() {
        if (!hasAudioContext) return null;
        if (state.audioContext) return state.audioContext;
        try {
          const Context = window.AudioContext || window.webkitAudioContext;
          const ctx = new Context();
          state.audioContext = ctx;
          return ctx;
        } catch (err) {
          console.warn('Unable to create AudioContext for click track', err);
          return null;
        }
      }

      function resumeAudioContext() {
        const ctx = ensureAudioContext();
        if (!ctx) return null;
        if (ctx.state === 'suspended') {
          ctx.resume().catch((error) => {
            console.warn('AudioContext resume failed', error);
          });
        }
        return ctx;
      }

      function updateClickToggleButton() {
        if (!clickToggleButton) return;
        const label = state.clickTrackEnabled ? 'Click Track: On' : 'Click Track: Off';
        clickToggleButton.textContent = label;
        clickToggleButton.setAttribute('aria-pressed', state.clickTrackEnabled ? 'true' : 'false');
        clickToggleButton.classList.toggle('active', state.clickTrackEnabled);
      }

      function setClickTrackEnabled(enabled) {
        state.clickTrackEnabled = Boolean(enabled) && hasAudioContext;
        updateClickToggleButton();
        if (state.clickTrackEnabled) {
          resumeAudioContext();
        }
      }

      function triggerClick(isAccent) {
        if (!state.clickTrackEnabled || audio.paused) return;
        const ctx = resumeAudioContext();
        if (!ctx || ctx.state !== 'running') return;
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.value = isAccent ? 1800 : 1200;

        const gain = ctx.createGain();
        const now = ctx.currentTime;
        const startGain = isAccent ? 0.18 : 0.12;
        gain.gain.setValueAtTime(startGain, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(now);
        osc.stop(now + 0.1);
      }

      function updateDetectionStatus(message) {
        if (!statusDetect) return;
        if (message) {
          statusDetect.textContent = message;
          updateAnchorButtonStates();
          return;
        }
        if (state.autoDetecting) {
          statusDetect.textContent = 'Analyzing…';
          updateAnchorButtonStates();
          return;
        }
        const info = state.detectionInfo || {};
        const bpmLabel = Number.isFinite(state.bpm) ? ` ${Math.round(state.bpm)}` : '';
        if (info.source === 'detected') {
          const conf = Number.isFinite(info.confidence) ? ` (${Math.round(info.confidence * 100)}%)` : '';
          const manualAnchors = Array.isArray(state.anchors) ? state.anchors.filter((anchor) => anchor.manual) : [];
          const anchorCount = manualAnchors.length;
          const anchorLabel = anchorCount > 0 ? ` · ${anchorCount} anchor${anchorCount === 1 ? '' : 's'}` : '';
          statusDetect.textContent = `Auto BPM${bpmLabel}${conf}${anchorLabel}`;
        } else if (info.method === 'tap') {
          statusDetect.textContent = `Tap BPM${bpmLabel}`;
        } else {
          statusDetect.textContent = `Manual BPM${bpmLabel}`;
        }
        updateAnchorButtonStates();
      }

      function updateAnchorButtonStates() {
        const hasBeatMap = Array.isArray(state.baseBeatTimes) && state.baseBeatTimes.length > 0;
        if (anchorCurrentButton) {
          anchorCurrentButton.disabled = !hasBeatMap;
        }
        if (clearAnchorsButton) {
          const hasManual = hasBeatMap && Array.isArray(state.anchors) && state.anchors.some((anchor) => anchor.manual);
          clearAnchorsButton.disabled = !hasManual;
        }
      }

      function ensureEdgeAnchors() {
        if (!Array.isArray(state.baseBeatTimes) || state.baseBeatTimes.length === 0) return;
        const firstIndex = 0;
        const lastIndex = state.baseBeatTimes.length - 1;
        if (!state.anchors.some((anchor) => anchor.beat === firstIndex)) {
          state.anchors.push({ beat: firstIndex, time: state.baseBeatTimes[firstIndex], manual: false });
        }
        if (!state.anchors.some((anchor) => anchor.beat === lastIndex)) {
          state.anchors.push({ beat: lastIndex, time: state.baseBeatTimes[lastIndex], manual: false });
        }
      }

      function sortAnchors() {
        state.anchors.sort((a, b) => a.beat - b.beat);
      }

      function computeFinalBeatTimes() {
        const base = state.baseBeatTimes;
        if (!Array.isArray(base) || base.length === 0) {
          state.finalBeatTimes = null;
          updateDetectionStatus();
          return;
        }
        ensureEdgeAnchors();
        sortAnchors();
        const beats = base.length;
        const result = new Float64Array(beats);
        const duration = Number.isFinite(audio.duration) ? audio.duration : base[base.length - 1];

        for (let i = 0; i < state.anchors.length - 1; i += 1) {
          const start = state.anchors[i];
          const end = state.anchors[i + 1];
          const startBeat = start.beat;
          const endBeat = end.beat;
          const baseStart = base[startBeat];
          const baseEnd = base[endBeat];
          const targetStart = Math.max(0, Math.min(duration, start.time));
          const targetEnd = Math.max(0, Math.min(duration, end.time));
          const span = baseEnd - baseStart;
          const targetSpan = targetEnd - targetStart;

          for (let beat = startBeat; beat <= endBeat; beat += 1) {
            if (beat === startBeat) {
              result[beat] = targetStart;
            } else if (beat === endBeat) {
              result[beat] = targetEnd;
            } else if (span <= 0) {
              const step = targetSpan / Math.max(1, endBeat - startBeat);
              result[beat] = targetStart + step * (beat - startBeat);
            } else {
              const ratio = (base[beat] - baseStart) / span;
              const clampedRatio = Math.min(Math.max(ratio, 0), 1);
              result[beat] = targetStart + clampedRatio * targetSpan;
            }
          }
        }

        for (let i = 1; i < result.length; i += 1) {
          if (result[i] < result[i - 1]) {
            result[i] = result[i - 1];
          }
        }

        state.finalBeatTimes = Array.from(result);
        state.totalBeats = result.length;
        const startBeat = updateGridStartBeat(state.totalBeats);
        const availableBeats = Math.max(0, state.totalBeats - startBeat);
        state.gridBeatCount = Math.max(availableBeats, 8);
        state.offset = result[0];
        if (state.totalBeats > 1) {
          const span = result[result.length - 1] - result[0];
          const averageDuration = span / (state.totalBeats - 1);
          if (Number.isFinite(averageDuration) && averageDuration > 0) {
            state.beatDuration = averageDuration;
            state.bpm = 60 / averageDuration;
          }
        }
        updateDetectionStatus();
        drawWaveform();
      }

      function getActiveBeatTimes() {
        if (Array.isArray(state.finalBeatTimes) && state.finalBeatTimes.length > 0) {
          return state.finalBeatTimes;
        }
        return null;
      }

      function setBaseBeatTimes(baseTimes, info = {}) {
        if (!Array.isArray(baseTimes) || baseTimes.length === 0) return;
        state.baseBeatTimes = Array.from(baseTimes);
        state.anchors = [];
        if (info.method || info.source || info.confidence != null) {
          state.detectionInfo = {
            method: info.method != null ? info.method : state.detectionInfo.method,
            confidence: info.confidence != null ? info.confidence : state.detectionInfo.confidence,
            source: info.source != null ? info.source : 'detected',
          };
        } else {
          state.detectionInfo = { method: 'auto', confidence: info.confidence != null ? info.confidence : null, source: 'detected' };
        }
        if (Number.isFinite(info.bpm)) {
          state.bpm = info.bpm;
        }
        if (Number.isFinite(info.introOffsetBeats)) {
          state.introOffsetBeats = Math.max(0, info.introOffsetBeats);
          introOffsetInput.value = String(state.introOffsetBeats);
        }
        computeFinalBeatTimes();
        if (Number.isFinite(state.bpm)) {
          bpmInput.value = String(Math.round(state.bpm));
        }
        if (Number.isFinite(state.offset)) {
          offsetInput.value = state.offset.toFixed(3);
        }
      }

      function timeToBeatIndex(currentTime) {
        const beats = getActiveBeatTimes();
        if (Array.isArray(beats) && beats.length > 0) {
          if (currentTime < beats[0]) {
            return currentTime < beats[0] - 0.05 ? -1 : 0;
          }
          let low = 0;
          let high = beats.length - 1;
          let best = beats.length - 1;
          while (low <= high) {
            const mid = Math.floor((low + high) / 2);
            if (beats[mid] <= currentTime) {
              best = mid;
              low = mid + 1;
            } else {
              high = mid - 1;
            }
          }
          return best;
        }
        if (!Number.isFinite(state.beatDuration) || state.beatDuration <= 0) {
          return -1;
        }
        const aligned = currentTime - state.offset;
        if (aligned < 0) return -1;
        return Math.floor(aligned / state.beatDuration);
      }

      function addAnchor(beatIndex, time, options = {}) {
        const { manual = true, silent = false } = options;
        const base = state.baseBeatTimes;
        if (!Array.isArray(base) || !Number.isFinite(beatIndex)) return;
        const clampedBeat = Math.min(Math.max(Math.round(beatIndex), 0), base.length - 1);
        const duration = Number.isFinite(audio.duration) ? audio.duration : base[base.length - 1];
        const clampedTime = Math.min(Math.max(time, 0), duration);
        const existingIndex = state.anchors.findIndex((anchor) => anchor.beat === clampedBeat);
        const anchorData = { beat: clampedBeat, time: clampedTime, manual };
        if (existingIndex >= 0) {
          state.anchors[existingIndex] = anchorData;
        } else {
          state.anchors.push(anchorData);
          sortAnchors();
        }
        computeFinalBeatTimes();
        if (!silent) {
          queueSave();
        }
      }

      function clearManualAnchors() {
        state.anchors = state.anchors.filter((anchor) => !anchor.manual);
        computeFinalBeatTimes();
        queueSave();
      }

      function clearDetectedBeatMap() {
        state.baseBeatTimes = null;
        state.finalBeatTimes = null;
        state.anchors = [];
        state.detectionInfo = { method: 'manual', confidence: null, source: 'manual' };
        updateGridStartBeat(state.totalBeats);
        updateDetectionStatus();
        drawWaveform();
      }

      function updateGridStartBeat(totalBeatsOverride) {
        const totalBeats = Number.isFinite(totalBeatsOverride) ? totalBeatsOverride : state.totalBeats;
        let start = Math.max(0, Math.floor(state.introOffsetBeats || 0));
        if (Number.isFinite(totalBeats) && totalBeats > 0 && start >= totalBeats) {
          start = Math.max(0, totalBeats - 1);
        }
        state.gridStartBeat = start;
        return start;
      }

      function applyPendingTimingFromImport() {
        if (Array.isArray(state.pendingBeats) && state.pendingBeats.length > 0) {
          const info = state.pendingDetectionInfo || {};
          if (state.pendingIntroOffsetBeats != null) {
            info.introOffsetBeats = state.pendingIntroOffsetBeats;
          }
          setBaseBeatTimes(state.pendingBeats, info);
          if (Array.isArray(state.pendingAnchors)) {
            state.pendingAnchors.forEach((anchor) => {
              if (anchor && Number.isFinite(anchor.beat) && Number.isFinite(anchor.time)) {
                addAnchor(anchor.beat, anchor.time, { manual: true, silent: true });
              }
            });
            computeFinalBeatTimes();
          }
        }
        if (state.pendingIntroOffsetBeats != null) {
          state.introOffsetBeats = Math.max(0, state.pendingIntroOffsetBeats);
          introOffsetInput.value = String(state.introOffsetBeats);
          updateGridStartBeat(state.totalBeats);
        }
        state.pendingBeats = null;
        state.pendingAnchors = null;
        state.pendingDetectionInfo = null;
        state.pendingIntroOffsetBeats = null;
        updateDetectionStatus();
      }

      function finalizeTimingChange({ preserveNotes = true } = {}) {
        computeFinalBeatTimes();
        buildGrid({ preserveExisting: preserveNotes, skipStorage: true });
      }

      // Recompute the phrase/beat grid using audio duration plus BPM + offset.
      function buildGrid({ preserveExisting = true, skipStorage = false } = {}) {
        if (!Number.isFinite(audio.duration) || audio.duration <= 0) {
          return;
        }

        const beatTimes = getActiveBeatTimes();
        let totalBeats = 0;
        if (Array.isArray(beatTimes) && beatTimes.length > 0) {
          totalBeats = beatTimes.length;
        } else if (Number.isFinite(state.beatDuration) && state.beatDuration > 0) {
          const rawBeats = (audio.duration - state.offset) / state.beatDuration;
          totalBeats = Math.max(0, Math.ceil(rawBeats));
        } else {
          return;
        }

        state.totalBeats = totalBeats;
        const startBeat = updateGridStartBeat(totalBeats);
        const availableBeats = Math.max(0, totalBeats - startBeat);
        state.gridBeatCount = Math.max(availableBeats, 8);
        const requiredPhrases = Math.max(1, Math.ceil(state.gridBeatCount / 8));
        const introBeats = Math.max(0, Math.floor(state.introOffsetBeats || 0));
        ensureIntroNotesSize(introBeats);

        if (!preserveExisting) {
          state.phraseData = Array.from({ length: requiredPhrases }, () => Array(8).fill(''));
        } else {
          ensurePhraseDataSize(requiredPhrases);
        }

        renderGrid();
        if (!skipStorage) {
          loadFromStorage();
        }
        queueSave();
      }

      function renderGrid() {
        state.cellIndexMap.clear();
        gridBody.innerHTML = '';
        const fragment = document.createDocumentFragment();
        const introBeats = Math.max(0, Math.floor(state.introOffsetBeats || 0));
        ensureIntroNotesSize(introBeats);
        if (introBeats > 0) {
          const introRows = Math.ceil(introBeats / 8);
          for (let introRowIndex = 0; introRowIndex < introRows; introRowIndex += 1) {
          const introRow = document.createElement('tr');
          introRow.className = 'intro-row';
          const headerCell = document.createElement('th');
          headerCell.scope = 'row';
          headerCell.textContent = introRows === 1
            ? 'Intro'
            : `Intro ${introRowIndex + 1}`;
          introRow.appendChild(headerCell);
          for (let beat = 0; beat < 8; beat += 1) {
            const td = document.createElement('td');
            td.className = 'beat-cell intro-cell';
            td.spellcheck = false;
            const absoluteCount = introRowIndex * 8 + beat + 1;
            if (absoluteCount <= introBeats) {
              const beatIndex = absoluteCount - 1;
              td.dataset.beatIndex = String(beatIndex);
              td.dataset.beatNumber = String(absoluteCount);
              td.dataset.inactive = 'false';
              td.dataset.intro = 'true';
              td.dataset.count = String(absoluteCount);
              td.contentEditable = 'true';
              const note = Array.isArray(state.introNotes) && state.introNotes[beatIndex]
                ? state.introNotes[beatIndex]
                : '';
              td.textContent = note;
              state.cellIndexMap.set(beatIndex, td);
            } else {
              td.contentEditable = 'false';
              td.dataset.inactive = 'true';
              td.dataset.intro = 'true';
              td.dataset.active = 'false';
              td.classList.add('is-placeholder');
              td.textContent = '';
              }
              introRow.appendChild(td);
            }
            fragment.appendChild(introRow);
          }
        }
        const startBeat = state.gridStartBeat || 0;

        for (let phraseIndex = 0; phraseIndex < state.phraseData.length; phraseIndex += 1) {
          const tr = document.createElement('tr');
          const headerCell = document.createElement('th');
          headerCell.scope = 'row';
          headerCell.textContent = `P${phraseIndex + 1}`;
          tr.appendChild(headerCell);

          const rowData = state.phraseData[phraseIndex];
          for (let beat = 0; beat < 8; beat += 1) {
            const td = document.createElement('td');
            td.className = 'beat-cell';
            td.contentEditable = 'true';
            td.spellcheck = false;
            td.dataset.phrase = String(phraseIndex);
            const beatIndex = startBeat + phraseIndex * 8 + beat;
            td.dataset.beatIndex = String(beatIndex);
            td.dataset.beatNumber = String(beat + 1);
            const inactive = beatIndex >= state.totalBeats;
            td.dataset.inactive = inactive ? 'true' : 'false';
            const cellValue = rowData && rowData[beat] != null ? rowData[beat] : '';
            td.textContent = cellValue;
            tr.appendChild(td);
            if (!inactive) {
              td.dataset.count = String(beatIndex + 1);
              state.cellIndexMap.set(beatIndex, td);
            } else {
              td.removeAttribute('data-count');
            }
          }
          fragment.appendChild(tr);
        }

        gridBody.appendChild(fragment);
      }

      // Highlight the active beat cell for the current playback moment.
      function highlightBeat(beatIndex) {
        if (beatIndex === state.lastHighlightBeat) return;
        state.lastHighlightBeat = beatIndex;

        if (state.clickTrackEnabled && beatIndex != null && beatIndex >= 0 && !audio.paused) {
          const startBeat = state.gridStartBeat || 0;
          const relativeIndex = beatIndex - startBeat;
          const isAccent = relativeIndex >= 0 ? relativeIndex % 8 === 0 : false;
          triggerClick(isAccent);
        }

        if (state.currentCell) {
          state.currentCell.classList.remove('is-current');
        }
        if (state.currentRow) {
          state.currentRow.classList.remove('is-current');
        }

        if (beatIndex == null || beatIndex < 0) {
          state.currentCell = null;
          state.currentRow = null;
          return;
        }

        const cell = state.cellIndexMap.get(beatIndex);
        if (!cell) {
          state.currentCell = null;
          state.currentRow = null;
          return;
        }

        const row = cell.parentElement;
        cell.classList.add('is-current');
        row.classList.add('is-current');
        state.currentCell = cell;
        state.currentRow = row;

        maybeScrollIntoView(row, cell);
      }

      function maybeScrollIntoView(row, cell) {
        if (!row || !cell) return;
        const activeEl = document.activeElement;
        if (activeEl && activeEl.isContentEditable) return;

        const containerRect = gridContainer.getBoundingClientRect();
        const cellRect = cell.getBoundingClientRect();
        const pad = 24;
        if (cellRect.top < containerRect.top + pad || cellRect.bottom > containerRect.bottom - pad) {
          cell.scrollIntoView({ block: 'center', behavior: 'smooth' });
        }
      }

      function formatTime(seconds) {
        if (!Number.isFinite(seconds) || seconds < 0) seconds = 0;
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      function updateStatusBar(currentBeatIndex) {
        const currentTime = audio.currentTime || 0;
        const totalTime = Number.isFinite(audio.duration) ? audio.duration : 0;
        statusTime.textContent = `${formatTime(currentTime)} / ${formatTime(totalTime)}`;

        if (currentBeatIndex == null || currentBeatIndex < 0) {
          statusBeat.textContent = 'Intro beat 0';
          return;
        }
        const introBeats = Math.max(0, Math.floor(state.introOffsetBeats || 0));
        if (currentBeatIndex < introBeats) {
          const introBeatNumber = currentBeatIndex + 1;
          statusBeat.textContent = `Intro beat ${introBeatNumber}`;
          return;
        }
        const beatCount = currentBeatIndex + 1;
        const phrase = Math.floor((beatCount - 1) / 8) + 1;
        const beatNumber = ((beatCount - 1) % 8) + 1;
        statusBeat.textContent = `Beat ${beatNumber} (Phrase ${phrase})`;
      }

      function syncTimeline() {
        const duration = audio.duration || 0;
        const current = audio.currentTime || 0;
        const progress = duration > 0 ? current / duration : 0;
        const clampedProgress = Math.min(Math.max(progress, 0), 1);
        if (timelineFill) {
          timelineFill.style.width = `${clampedProgress * 100}%`;
        }
        if (timelineCursor) {
          timelineCursor.style.left = `${clampedProgress * 100}%`;
        }
      }

      // requestAnimationFrame loop — derives beat index directly from audio.currentTime.
      function playbackLoop() {
        let beatIndex = -1;
        if (Number.isFinite(audio.currentTime)) {
          beatIndex = timeToBeatIndex(audio.currentTime);
          if (state.totalBeats > 0 && beatIndex >= state.totalBeats) {
            beatIndex = state.totalBeats - 1;
          }
        }

        highlightBeat(beatIndex);
        syncTimeline();
        updateStatusBar(beatIndex);

        state.rafId = window.requestAnimationFrame(playbackLoop);
      }

      function seekTo(timeInSeconds) {
        if (!Number.isFinite(timeInSeconds)) return;
        const clamped = Math.min(Math.max(timeInSeconds, 0), Number.isFinite(audio.duration) ? audio.duration : 0);
        audio.currentTime = clamped;
      }

      // Convert a beat index back into a precise audio timestamp (includes offset).
      function beatIndexToTime(beatIndex) {
        if (!Number.isFinite(beatIndex)) return 0;
        const beats = getActiveBeatTimes();
        if (Array.isArray(beats) && beats.length > 0) {
          const clamped = Math.min(Math.max(Math.round(beatIndex), 0), beats.length - 1);
          const time = beats[clamped];
          if (!Number.isFinite(audio.duration)) return Math.max(time, 0);
          return Math.min(Math.max(time, 0), audio.duration);
        }
        const targetTime = state.offset + beatIndex * state.beatDuration;
        if (!Number.isFinite(targetTime)) return 0;
        if (!Number.isFinite(audio.duration)) return Math.max(targetTime, 0);
        return Math.min(Math.max(targetTime, 0), audio.duration);
      }

      function handleCellInput(event) {
        const cell = event.target.closest('td.beat-cell');
        if (!cell) return;
        const phraseIdx = Number.parseInt(cell.dataset.phrase, 10);
        const beatNumber = Number.parseInt(cell.dataset.beatNumber, 10) - 1;
        if (!Number.isFinite(phraseIdx) || !Number.isFinite(beatNumber)) return;
        const row = state.phraseData[phraseIdx];
        if (!row) return;
        row[beatNumber] = cell.textContent.trim();
        queueSave();
      }

      function handleCellClick(event) {
        const cell = event.target.closest('td.beat-cell');
        if (!cell) return;
        const beatIndex = Number.parseInt(cell.dataset.beatIndex, 10);
        if (!Number.isFinite(beatIndex) || beatIndex < 0) return;
        if (cell.dataset.inactive === 'true') return;
        if (event.metaKey || event.ctrlKey) {
          event.preventDefault();
          event.stopPropagation();
          const timestamp = Number.isFinite(audio.currentTime) ? audio.currentTime : beatIndexToTime(beatIndex);
          addAnchor(beatIndex, timestamp, { manual: true });
          return;
        }
        const selection = window.getSelection();
        if (selection && selection.type === 'Range' && selection.toString()) return;
        seekTo(beatIndexToTime(beatIndex));
      }

      function handlePastePlainText(event) {
        const cell = event.target.closest('td.beat-cell');
        if (!cell) return;
        event.preventDefault();
        const text = (event.clipboardData || window.clipboardData).getData('text/plain');
        document.execCommand('insertText', false, text);
      }

      async function getDecodedAudioBuffer() {
        if (!state.objectUrl) throw new Error('Load an audio track first.');
        if (!hasAudioContext) throw new Error('Web Audio is unavailable in this browser.');
        const ctx = ensureAudioContext();
        if (!ctx) throw new Error('Unable to create AudioContext.');
        if (state.analysisCache && state.analysisCache.buffer) {
          return state.analysisCache.buffer;
        }
        if (!state.analysisCache || !state.analysisCache.raw) {
          const response = await fetch(state.objectUrl);
          if (!response.ok) throw new Error('Unable to read audio data for analysis.');
          const rawBuffer = await response.arrayBuffer();
          state.analysisCache = { raw: rawBuffer };
        }
        const decoded = await ctx.decodeAudioData(state.analysisCache.raw.slice(0));
        state.analysisCache.buffer = decoded;
        return decoded;
      }

      function downmixToMono(audioBuffer) {
        const { numberOfChannels, length } = audioBuffer;
        if (numberOfChannels === 1) {
          const mono = new Float32Array(length);
          mono.set(audioBuffer.getChannelData(0));
          return mono;
        }
        const channels = [];
        for (let ch = 0; ch < numberOfChannels; ch += 1) {
          channels.push(audioBuffer.getChannelData(ch));
        }
        const mono = new Float32Array(length);
        for (let i = 0; i < length; i += 1) {
          let sum = 0;
          for (let ch = 0; ch < channels.length; ch += 1) {
            sum += channels[ch][i];
          }
          mono[i] = sum / channels.length;
        }
        return mono;
      }

      function computeOnsetEnvelope(samples, sampleRate) {
        const frameSize = 1024;
        const hopSize = 512;
        const totalFrames = Math.max(0, Math.floor((samples.length - frameSize) / hopSize));
        const envelope = new Float32Array(totalFrames);
        let prevEnergy = 0;
        for (let frame = 0; frame < totalFrames; frame += 1) {
          let energy = 0;
          const start = frame * hopSize;
          for (let i = 0; i < frameSize; i += 1) {
            const sample = samples[start + i];
            energy += sample * sample;
          }
          const diff = energy - prevEnergy;
          envelope[frame] = diff > 0 ? diff : 0;
          prevEnergy = energy;
        }
        if (envelope.length === 0) {
          return { envelope, frameDuration: hopSize / sampleRate, hopSize, frameSize };
        }
        const mean = envelope.reduce((acc, value) => acc + value, 0) / envelope.length;
        let max = 0;
        for (let i = 0; i < envelope.length; i += 1) {
          const adjusted = Math.max(0, envelope[i] - mean * 0.5);
          envelope[i] = adjusted;
          if (adjusted > max) max = adjusted;
        }
        if (max > 0) {
          for (let i = 0; i < envelope.length; i += 1) {
            envelope[i] /= max;
          }
        }
        return { envelope, frameDuration: hopSize / sampleRate, hopSize, frameSize };
      }

      function computeWaveformPeaks(samples, targetPoints = 2000) {
        if (!samples || samples.length === 0) {
          return { peaks: null, count: 0 };
        }
        const totalSamples = samples.length;
        const desiredPoints = Math.max(256, Math.min(targetPoints, totalSamples));
        const bucketSize = Math.max(1, Math.floor(totalSamples / desiredPoints));
        const pointCount = Math.max(1, Math.ceil(totalSamples / bucketSize));
        const peaks = new Float32Array(pointCount * 2);
        let peakIndex = 0;
        let globalMax = 0;
        for (let i = 0; i < pointCount; i += 1) {
          const start = i * bucketSize;
          if (start >= totalSamples) break;
          const end = Math.min(totalSamples, start + bucketSize);
          let min = Infinity;
          let max = -Infinity;
          for (let j = start; j < end; j += 1) {
            const value = samples[j];
            if (value < min) min = value;
            if (value > max) max = value;
          }
          if (min === Infinity) {
            min = 0;
          }
          if (max === -Infinity) {
            max = 0;
          }
          peaks[peakIndex] = min;
          peaks[peakIndex + 1] = max;
          if (Math.abs(min) > globalMax) globalMax = Math.abs(min);
          if (Math.abs(max) > globalMax) globalMax = Math.abs(max);
          peakIndex += 2;
        }
        if (globalMax > 0) {
          for (let i = 0; i < peakIndex; i += 1) {
            peaks[i] /= globalMax;
          }
        }
        return { peaks, count: peakIndex / 2 };
      }

      function drawWaveform() {
        if (!waveformCanvas) return;
        const container = waveformCanvas.parentElement;
        if (!container) return;
        const rect = container.getBoundingClientRect();
        const width = Math.max(1, Math.floor(rect.width));
        const height = Math.max(1, Math.floor(rect.height));
        const dpr = window.devicePixelRatio || 1;
        const canvasWidth = Math.max(1, Math.floor(width * dpr));
        const canvasHeight = Math.max(1, Math.floor(height * dpr));
        if (waveformCanvas.width !== canvasWidth || waveformCanvas.height !== canvasHeight) {
          waveformCanvas.width = canvasWidth;
          waveformCanvas.height = canvasHeight;
        }
        const ctx = waveformCanvas.getContext('2d');
        if (!ctx) return;
        ctx.save();
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, width, height);

        const peaks = state.waveformPeaks;
        const count = state.waveformPeakCount || 0;
        if (peaks && count > 0) {
          const midY = height / 2;
          const amplitude = (height / 2) * 0.9;
          ctx.fillStyle = 'rgba(226, 232, 240, 0.85)';
          for (let i = 0; i < count; i += 1) {
            const minVal = peaks[i * 2];
            const maxVal = peaks[i * 2 + 1];
            const progress = count > 1 ? i / (count - 1) : 0;
            const nextProgress = count > 1 ? (i + 1) / (count - 1) : 1;
            const x = progress * width;
            const nextX = Math.min(width, nextProgress * width);
            const barWidth = Math.max((nextX - x), 1 / (window.devicePixelRatio || 1));
            const minY = midY + Math.min(minVal, maxVal) * amplitude;
            const maxY = midY + Math.max(minVal, maxVal) * amplitude;
            const drawY = Math.min(minY, maxY);
            const drawHeight = Math.max(1, Math.abs(maxY - minY));
            ctx.fillRect(x, drawY, barWidth, drawHeight);
          }
        } else {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.45)';
          ctx.font = '12px "Inter", "Segoe UI", sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const message = hasAudioContext ? 'Waveform loading…' : 'Waveform preview unavailable';
          ctx.fillText(message, width / 2, height / 2);
        }

        const beats = getActiveBeatTimes();
        const duration = Number.isFinite(audio.duration) && audio.duration > 0
          ? audio.duration
          : (state.waveformDuration || 0);
        if (Array.isArray(beats) && beats.length > 0 && duration > 0) {
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(148, 163, 184, 0.4)';
          ctx.beginPath();
          for (let i = 0; i < beats.length; i += 1) {
            const time = beats[i];
            if (!Number.isFinite(time)) continue;
            const position = (time / duration) * width;
            const x = Math.min(width, Math.max(0, position));
            ctx.moveTo(x + 0.5, 0);
            ctx.lineTo(x + 0.5, height);
          }
          ctx.stroke();

          const startBeat = state.gridStartBeat || 0;
          ctx.lineWidth = 1.5;
          ctx.strokeStyle = 'rgba(255, 107, 107, 0.75)';
          ctx.beginPath();
          for (let beatIndex = startBeat; beatIndex < beats.length; beatIndex += 8) {
            const time = beats[beatIndex];
            if (!Number.isFinite(time)) continue;
            const position = (time / duration) * width;
            const x = Math.min(width, Math.max(0, position));
            ctx.moveTo(x + 0.5, 0);
            ctx.lineTo(x + 0.5, height);
          }
          ctx.stroke();
        }
        ctx.restore();
      }

      function refreshWaveformPreview() {
        if (!waveformCanvas) return Promise.resolve();
        if (!state.objectUrl) {
          state.waveformPeaks = null;
          state.waveformPeakCount = 0;
          state.waveformDuration = Number.isFinite(audio.duration) ? audio.duration : 0;
          drawWaveform();
          return Promise.resolve();
        }
        if (!hasAudioContext) {
          state.waveformPeaks = null;
          state.waveformPeakCount = 0;
          state.waveformDuration = Number.isFinite(audio.duration) ? audio.duration : 0;
          drawWaveform();
          return Promise.resolve();
        }
        if (state.waveformLoading) {
          return state.waveformLoading;
        }
        const loadPromise = (async () => {
          try {
            const buffer = await getDecodedAudioBuffer();
            const mono = downmixToMono(buffer);
            const { peaks, count } = computeWaveformPeaks(mono);
            state.waveformPeaks = peaks;
            state.waveformPeakCount = count;
            state.waveformDuration = buffer.duration;
          } catch (err) {
            console.warn('Waveform preview unavailable', err);
            state.waveformPeaks = null;
            state.waveformPeakCount = 0;
            state.waveformDuration = Number.isFinite(audio.duration) ? audio.duration : 0;
          }
        })();
        state.waveformLoading = loadPromise;
        loadPromise.finally(() => {
          state.waveformLoading = null;
          drawWaveform();
        });
        return loadPromise;
      }

      function estimateTempoFromEnvelope(envelope, frameDuration) {
        const minBpm = 60;
        const maxBpm = 200;
        const minLag = Math.max(1, Math.round((60 / maxBpm) / frameDuration));
        const maxLag = Math.max(minLag + 1, Math.round((60 / minBpm) / frameDuration));
        let bestLag = minLag;
        let bestScore = -Infinity;
        let secondScore = -Infinity;
        const scores = new Map();
        for (let lag = minLag; lag <= maxLag; lag += 1) {
          let score = 0;
          for (let i = lag; i < envelope.length; i += 1) {
            score += envelope[i] * envelope[i - lag];
          }
          scores.set(lag, score);
          if (score > bestScore) {
            secondScore = bestScore;
            bestScore = score;
            bestLag = lag;
          } else if (score > secondScore) {
            secondScore = score;
          }
        }
        if (bestScore <= 0) {
          return { bpm: NaN, lag: bestLag, confidence: 0 };
        }
        const halfLag = Math.round(bestLag / 2);
        if (halfLag >= minLag) {
          const halfScore = scores.get(halfLag) || 0;
          if (halfScore * 1.05 > bestScore) {
            bestLag = halfLag;
            bestScore = halfScore;
          }
        }
        const doubleLag = bestLag * 2;
        if (doubleLag <= maxLag) {
          const doubleScore = scores.get(doubleLag) || 0;
          if (doubleScore > bestScore * 1.2) {
            bestLag = doubleLag;
            bestScore = doubleScore;
          }
        }
        const bpm = 60 / (bestLag * frameDuration);
        const confidence = bestScore > 0 && secondScore > 0 ? Math.min(bestScore / secondScore, 2) / 2 : 0.5;
        return { bpm, lag: bestLag, confidence };
      }

      function estimateBeatOffset(envelope, periodFrames) {
        const limit = Math.min(periodFrames, envelope.length);
        let bestOffset = 0;
        let bestScore = -Infinity;
        for (let offset = 0; offset < limit; offset += 1) {
          let score = 0;
          for (let frame = offset; frame < envelope.length; frame += periodFrames) {
            score += envelope[frame];
          }
          if (score > bestScore) {
            bestScore = score;
            bestOffset = offset;
          }
        }
        return { offsetFrame: bestOffset, score: bestScore };
      }

      function refineBeatTimeline(baseTimes, envelope, frameDuration) {
        const refined = new Float64Array(baseTimes.length);
        const windowSeconds = 0.08;
        const windowFrames = Math.max(1, Math.round(windowSeconds / frameDuration));
        for (let i = 0; i < baseTimes.length; i += 1) {
          const targetTime = baseTimes[i];
          const centerFrame = Math.round(targetTime / frameDuration);
          let bestFrame = centerFrame;
          let bestValue = 0;
          const start = Math.max(0, centerFrame - windowFrames);
          const end = Math.min(envelope.length - 1, centerFrame + windowFrames);
          for (let frame = start; frame <= end; frame += 1) {
            const value = envelope[frame];
            if (value > bestValue) {
              bestValue = value;
              bestFrame = frame;
            }
          }
          refined[i] = bestFrame * frameDuration;
        }
        for (let i = 1; i < refined.length; i += 1) {
          if (refined[i] <= refined[i - 1]) {
            refined[i] = refined[i - 1] + frameDuration * 0.01;
          }
        }
        return Array.from(refined);
      }

      function generateBeatTimeline(firstBeatTime, beatPeriod, duration) {
        const beats = [];
        if (!Number.isFinite(firstBeatTime) || !Number.isFinite(beatPeriod) || beatPeriod <= 0) {
          return beats;
        }
        const startTime = Math.max(0, firstBeatTime);
        for (let time = startTime; time < duration; time += beatPeriod) {
          beats.push(time);
        }
        if (beats.length === 0 && duration > 0) {
          beats.push(startTime);
        }
        return beats;
      }

      async function autoDetectBeatGrid() {
        if (state.autoDetecting) return;
        if (!Number.isFinite(audio.duration) || audio.duration <= 0) {
          window.alert('Load an audio track before running detection.');
          return;
        }
        state.autoDetecting = true;
        if (autoDetectButton) autoDetectButton.disabled = true;
        updateDetectionStatus();
        try {
          const buffer = await getDecodedAudioBuffer();
          const mono = downmixToMono(buffer);
          const { envelope, frameDuration } = computeOnsetEnvelope(mono, buffer.sampleRate);
          if (!envelope || envelope.length === 0) {
            throw new Error('No onset information available.');
          }
          const tempo = estimateTempoFromEnvelope(envelope, frameDuration);
          if (!Number.isFinite(tempo.bpm) || tempo.bpm <= 0) {
            throw new Error('Unable to determine BPM automatically.');
          }
          const periodFrames = Math.max(1, Math.round(tempo.lag));
          const beatOffset = estimateBeatOffset(envelope, periodFrames);
          const firstBeatTime = beatOffset.offsetFrame * frameDuration;
          const beatPeriod = periodFrames * frameDuration;
          const duration = buffer.duration;
          const baseTimes = generateBeatTimeline(firstBeatTime, beatPeriod, duration + beatPeriod);
          const refinedTimes = refineBeatTimeline(baseTimes, envelope, frameDuration).filter((time) => time <= duration + beatPeriod * 0.5);
          if (refinedTimes.length === 0) {
            throw new Error('Detection produced no beats.');
          }
          setBaseBeatTimes(refinedTimes, {
            method: 'auto-detect',
            confidence: tempo.confidence,
            bpm: tempo.bpm,
            source: 'detected',
          });
          finalizeTimingChange({ preserveNotes: true });
          queueSave();
        } catch (err) {
          console.error('Auto-detect failed', err);
          window.alert(`Auto-detect failed: ${err.message}`);
          state.detectionInfo = { method: 'manual', confidence: null, source: 'manual' };
        } finally {
          state.autoDetecting = false;
          if (autoDetectButton) autoDetectButton.disabled = false;
          updateDetectionStatus();
        }
      }

      function resetTapTempoHistory() {
        if (state.tapTempoResetId) {
          window.clearTimeout(state.tapTempoResetId);
          state.tapTempoResetId = null;
        }
        state.tapTempoHistory = [];
      }

      function handleTapTempo() {
        const now = performance.now();
        if (state.tapTempoHistory.length > 0 && now - state.tapTempoHistory[state.tapTempoHistory.length - 1] > 2000) {
          resetTapTempoHistory();
        }
        state.tapTempoHistory.push(now);
        if (state.tapTempoResetId) {
          window.clearTimeout(state.tapTempoResetId);
        }
        state.tapTempoResetId = window.setTimeout(() => {
          resetTapTempoHistory();
          updateDetectionStatus();
        }, 2500);

        if (state.tapTempoHistory.length < 2) {
          updateDetectionStatus();
          return;
        }
        const intervals = [];
        for (let i = 1; i < state.tapTempoHistory.length; i += 1) {
          intervals.push(state.tapTempoHistory[i] - state.tapTempoHistory[i - 1]);
        }
        const validIntervals = intervals.filter((ms) => ms > 0 && ms < 2000);
        if (validIntervals.length === 0) {
          return;
        }
        const sorted = validIntervals.slice().sort((a, b) => a - b);
        const trimmed = sorted.length > 3 ? sorted.slice(1, sorted.length - 1) : sorted;
        const averageMs = trimmed.reduce((acc, value) => acc + value, 0) / trimmed.length;
        if (!Number.isFinite(averageMs) || averageMs <= 0) {
          return;
        }
        const bpm = Math.min(200, Math.max(50, 60000 / averageMs));
        state.bpm = bpm;
        state.beatDuration = 60 / bpm;
        state.baseBeatTimes = null;
        state.finalBeatTimes = null;
        state.anchors = [];
        state.detectionInfo = { method: 'tap', confidence: null, source: 'manual' };
        updateDetectionStatus();
        buildGrid({ preserveExisting: false, skipStorage: true });
        queueSave();
      }

      function anchorCurrentBeat() {
        if (!Array.isArray(state.baseBeatTimes) || state.baseBeatTimes.length === 0) {
          window.alert('Run auto-detect before setting anchors.');
          return;
        }
        const beatIndex = Number.isFinite(state.lastHighlightBeat) && state.lastHighlightBeat != null
          ? state.lastHighlightBeat
          : timeToBeatIndex(audio.currentTime);
        if (!Number.isFinite(beatIndex) || beatIndex < 0) {
          window.alert('Play the track to highlight a beat before anchoring.');
          return;
        }
        const timestamp = Number.isFinite(audio.currentTime) ? audio.currentTime : beatIndexToTime(beatIndex);
        addAnchor(beatIndex, timestamp, { manual: true });
      }

      let saveTimeoutId = null;
      function queueSave() {
        if (!storageAvailable) return;
        window.clearTimeout(saveTimeoutId);
        saveTimeoutId = window.setTimeout(saveToStorage, 300);
      }

      function saveToStorage() {
        const key = getStorageKey();
        if (!key) return;
        const manualAnchors = Array.isArray(state.anchors) ? state.anchors.filter((anchor) => anchor.manual) : [];
        const trackDurationSeconds = Number.isFinite(audio.duration)
          ? Number(audio.duration.toFixed(6))
          : (Number.isFinite(state.waveformDuration) ? Number(state.waveformDuration.toFixed(6)) : null);
        const beatDurationSeconds = Number.isFinite(state.beatDuration)
          ? Number(state.beatDuration.toFixed(6))
          : (Number.isFinite(state.bpm) && state.bpm > 0 ? Number((60 / state.bpm).toFixed(6)) : null);
        const totalBeats = Number.isFinite(state.totalBeats) ? state.totalBeats : null;
        const gridStartBeat = Number.isFinite(state.gridStartBeat) ? state.gridStartBeat : 0;
        const payload = {
          meta: {
            track: state.trackId,
            trackLabel: trackLabelInput.value.trim() || undefined,
            trackFileName: state.trackFileName || null,
            bpm: state.bpm,
            beatDuration: beatDurationSeconds,
            offset: state.offset,
            introOffsetBeats: state.introOffsetBeats,
            savedAt: new Date().toISOString(),
            method: state.detectionInfo && state.detectionInfo.method ? state.detectionInfo.method : undefined,
            confidence: state.detectionInfo && Number.isFinite(state.detectionInfo.confidence) ? state.detectionInfo.confidence : null,
            detected: state.detectionInfo && state.detectionInfo.source === 'detected',
            trackDuration: trackDurationSeconds,
            totalBeats,
            gridStartBeat,
            schemaVersion: 2,
          },
          phrases: state.phraseData,
          beats: Array.isArray(state.baseBeatTimes) && state.baseBeatTimes.length > 0
            ? state.baseBeatTimes.map((time) => Number(time.toFixed(6)))
            : undefined,
          anchors: manualAnchors.length > 0
            ? manualAnchors.map((anchor) => ({ beat: anchor.beat, time: Number(anchor.time.toFixed(6)) }))
            : undefined,
        };
        state.savedTrackInfo = {
          trackId: state.trackId || null,
          trackLabel: trackLabelInput.value.trim() || null,
          fileName: state.trackFileName || null,
          duration: trackDurationSeconds,
          beatDuration: beatDurationSeconds,
          totalBeats,
          gridStartBeat,
        };
        try {
          window.localStorage.setItem(key, JSON.stringify(payload));
          const legacyKey = `cheer-8-count::${state.trackId}::${state.bpm}::${state.offset}`;
          if (legacyKey !== key) {
            window.localStorage.removeItem(legacyKey);
          }
        } catch (err) {
          console.warn('Failed to save notes', err);
          window.alert('Unable to autosave notes (storage may be full). Please export to JSON as a backup.');
        }
      }

      function loadFromStorage() {
        const key = getStorageKey();
        if (!key) return false;
        try {
          let raw = window.localStorage.getItem(key);
          if (!raw) {
            const legacyKey = `cheer-8-count::${state.trackId}::${state.bpm}::${state.offset}`;
            raw = window.localStorage.getItem(legacyKey);
            if (raw) {
              window.localStorage.removeItem(legacyKey);
            }
          }
          if (!raw) return false;
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== 'object') return false;

          state.savedTrackInfo = null;
          state.pendingTrackDuration = null;
          state.pendingTrackFileName = null;

          if (parsed.meta) {
            const savedInfo = {
              trackId: typeof parsed.meta.track === 'string' ? parsed.meta.track : null,
              trackLabel: typeof parsed.meta.trackLabel === 'string' ? parsed.meta.trackLabel : null,
              fileName: typeof parsed.meta.trackFileName === 'string' ? parsed.meta.trackFileName : null,
              duration: Number.isFinite(parsed.meta.trackDuration) ? parsed.meta.trackDuration : null,
              beatDuration: Number.isFinite(parsed.meta.beatDuration) ? parsed.meta.beatDuration : null,
              totalBeats: Number.isFinite(parsed.meta.totalBeats) ? parsed.meta.totalBeats : null,
              gridStartBeat: Number.isFinite(parsed.meta.gridStartBeat) ? parsed.meta.gridStartBeat : null,
            };
            state.savedTrackInfo = savedInfo;
            state.pendingTrackFileName = savedInfo.fileName;
            state.pendingTrackDuration = savedInfo.duration;
          }

          if (parsed.meta && Number.isFinite(parsed.meta.introOffsetBeats)) {
            state.introOffsetBeats = Math.max(0, parsed.meta.introOffsetBeats);
          }
          introOffsetInput.value = String(state.introOffsetBeats);

          if (Array.isArray(parsed.beats) && parsed.beats.length > 0) {
            const detectedFlag = parsed.meta && typeof parsed.meta.detected === 'boolean' ? parsed.meta.detected : true;
            const methodValue = parsed.meta && typeof parsed.meta.method === 'string' ? parsed.meta.method : (detectedFlag ? 'auto-detect' : 'manual');
            setBaseBeatTimes(parsed.beats, {
              method: methodValue,
              confidence: parsed.meta && Number.isFinite(parsed.meta.confidence) ? parsed.meta.confidence : null,
              bpm: parsed.meta && Number.isFinite(parsed.meta.bpm) ? parsed.meta.bpm : state.bpm,
              source: detectedFlag ? 'detected' : 'manual',
            });
            state.anchors = [];
            if (Array.isArray(parsed.anchors)) {
              parsed.anchors.forEach((anchor) => {
                if (anchor && Number.isFinite(anchor.beat) && Number.isFinite(anchor.time)) {
                  addAnchor(anchor.beat, anchor.time, { manual: true, silent: true });
                }
              });
              computeFinalBeatTimes();
            }
          } else {
            clearDetectedBeatMap();
          }

          if (Array.isArray(parsed.phrases)) {
            state.phraseData = parsed.phrases.map((row) => {
              if (!Array.isArray(row)) return Array(8).fill('');
              const normalized = row.slice(0, 8);
              while (normalized.length < 8) normalized.push('');
              return normalized;
            });
          }

          const beats = getActiveBeatTimes();
          if (Array.isArray(beats) && beats.length > 0) {
            state.totalBeats = beats.length;
          }
          updateGridStartBeat(state.totalBeats);
          const inferredAvailableBeats = Number.isFinite(state.totalBeats) ? Math.max(0, state.totalBeats - state.gridStartBeat) : 0;
          state.gridBeatCount = Math.max(inferredAvailableBeats, 8);

          const requiredPhrases = Math.max(1, Math.ceil(state.gridBeatCount / 8));
          ensurePhraseDataSize(requiredPhrases);
          renderGrid();
          if (Array.isArray(parsed.phrases)) {
            applyPhraseData(parsed.phrases);
          }
          updateDetectionStatus();
          if (
            state.savedTrackInfo
            && Number.isFinite(state.savedTrackInfo.duration)
            && Number.isFinite(audio.duration)
          ) {
            const durationDelta = Math.abs(audio.duration - state.savedTrackInfo.duration);
            if (durationDelta > 0.25) {
              console.warn(
                'Loaded track duration differs from saved beat grid metadata.',
                { savedDuration: state.savedTrackInfo.duration, currentDuration: audio.duration, delta: durationDelta },
              );
            }
          }
          if (
            state.savedTrackInfo
            && state.savedTrackInfo.fileName
            && state.trackFileName
            && state.savedTrackInfo.fileName !== state.trackFileName
          ) {
            console.warn(
              'Loaded track filename differs from saved beat grid metadata.',
              { savedFile: state.savedTrackInfo.fileName, currentFile: state.trackFileName },
            );
          }
          return true;
        } catch (err) {
          console.warn('Failed to load autosaved notes', err);
          return false;
        }
      }

      function applyPhraseData(phrases) {
        if (!Array.isArray(phrases)) return;
        const rows = Math.max(state.phraseData.length, phrases.length);
        ensurePhraseDataSize(rows);
        for (let i = 0; i < state.phraseData.length; i += 1) {
          const sourceRow = phrases[i];
          if (!Array.isArray(sourceRow)) continue;
          for (let j = 0; j < 8; j += 1) {
            const value = typeof sourceRow[j] === 'string' ? sourceRow[j] : '';
            state.phraseData[i][j] = value;
            const beatIndex = (state.gridStartBeat || 0) + i * 8 + j;
            const cell = state.cellIndexMap.get(beatIndex);
            if (cell) cell.textContent = value;
          }
        }
      }

      function exportJson() {
        const manualAnchors = Array.isArray(state.anchors) ? state.anchors.filter((anchor) => anchor.manual) : [];
        const trackDurationSeconds = Number.isFinite(audio.duration)
          ? Number(audio.duration.toFixed(6))
          : (Number.isFinite(state.waveformDuration) ? Number(state.waveformDuration.toFixed(6)) : null);
        const beatDurationSeconds = Number.isFinite(state.beatDuration)
          ? Number(state.beatDuration.toFixed(6))
          : (Number.isFinite(state.bpm) && state.bpm > 0 ? Number((60 / state.bpm).toFixed(6)) : null);
        const totalBeats = Number.isFinite(state.totalBeats) ? state.totalBeats : null;
        const gridStartBeat = Number.isFinite(state.gridStartBeat) ? state.gridStartBeat : 0;
        const payload = {
          meta: {
            track: state.trackId,
            trackLabel: trackLabelInput.value.trim() || undefined,
            trackFileName: state.trackFileName || null,
            bpm: state.bpm,
            offset: state.offset,
            introOffsetBeats: state.introOffsetBeats,
            beatDuration: beatDurationSeconds,
            trackDuration: trackDurationSeconds,
            totalBeats,
            gridStartBeat,
            method: state.detectionInfo && state.detectionInfo.method ? state.detectionInfo.method : undefined,
            confidence: state.detectionInfo && Number.isFinite(state.detectionInfo.confidence) ? state.detectionInfo.confidence : null,
            detected: state.detectionInfo && state.detectionInfo.source === 'detected',
            schemaVersion: 2,
          },
          phrases: state.phraseData,
          beats: Array.isArray(state.baseBeatTimes) && state.baseBeatTimes.length > 0
            ? state.baseBeatTimes.map((time) => Number(time.toFixed(6)))
            : undefined,
          anchors: manualAnchors.length > 0
            ? manualAnchors.map((anchor) => ({ beat: anchor.beat, time: Number(anchor.time.toFixed(6)) }))
            : undefined,
        };
        downloadFile(`${state.trackId || 'cheer-counts'}.json`, JSON.stringify(payload, null, 2), 'application/json');
      }

      function exportCsv() {
        const header = ['Phrase', '1', '2', '3', '4', '5', '6', '7', '8'];
        const rows = state.phraseData.map((row, idx) => [
          `P${idx + 1}`,
          ...row.map((cell) => (cell || '').replace(/"/g, '""')),
        ]);
        const lines = [header.join(','), ...rows.map((r) => r.map((cell) => `"${cell}"`).join(','))];
        const csv = lines.join('\n');
        downloadFile(`${state.trackId || 'cheer-counts'}.csv`, csv, 'text/csv');
      }

      function downloadFile(filename, data, mime) {
        const blob = new Blob([data], { type: mime });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.setTimeout(() => URL.revokeObjectURL(url), 0);
      }

      function handleImportFile(event) {
        const files = event.target.files;
        const file = files && files[0];
        if (!file) return;
        state.pendingTrackFileName = null;
        state.pendingTrackDuration = null;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const parsed = JSON.parse(reader.result);
            if (!parsed || typeof parsed !== 'object') throw new Error('Invalid JSON');
            const { meta, phrases, beats, anchors } = parsed;
            const hasBeats = Array.isArray(beats) && beats.length > 0;
            if (meta) {
              if (typeof meta.track === 'string') {
                trackLabelInput.value = meta.track;
                updateTrackId();
              }
              if (typeof meta.trackLabel === 'string' && meta.trackLabel.trim()) {
                trackLabelInput.value = meta.trackLabel.trim();
                updateTrackId();
              }
              if (typeof meta.trackFileName === 'string' && meta.trackFileName.trim()) {
                state.pendingTrackFileName = meta.trackFileName.trim();
              }
              if (Number.isFinite(meta.bpm)) {
                bpmInput.value = String(meta.bpm);
              }
              if (Number.isFinite(meta.offset) || typeof meta.offset === 'number') {
                offsetInput.value = String(meta.offset);
              }
              if (Number.isFinite(meta.introOffsetBeats) || typeof meta.introOffsetBeats === 'number') {
                const introBeats = Number(meta.introOffsetBeats);
                state.pendingIntroOffsetBeats = Math.max(0, introBeats);
                introOffsetInput.value = String(state.pendingIntroOffsetBeats);
              } else {
                state.pendingIntroOffsetBeats = state.introOffsetBeats;
              }
              if (Number.isFinite(meta.trackDuration)) {
                state.pendingTrackDuration = meta.trackDuration;
              }
              const detectedFlag = typeof meta.detected === 'boolean' ? meta.detected : hasBeats;
              const methodValue = typeof meta.method === 'string' ? meta.method : (detectedFlag ? 'auto-detect' : 'manual');
              state.pendingDetectionInfo = {
                method: methodValue,
                confidence: Number.isFinite(meta.confidence) ? meta.confidence : null,
                source: detectedFlag ? 'detected' : 'manual',
                bpm: Number.isFinite(meta.bpm) ? meta.bpm : undefined,
              };
              state.savedTrackInfo = {
                trackId: typeof meta.track === 'string' ? meta.track : state.trackId || null,
                trackLabel: typeof meta.trackLabel === 'string' && meta.trackLabel.trim() ? meta.trackLabel.trim() : (state.savedTrackInfo && state.savedTrackInfo.trackLabel) || null,
                fileName: typeof meta.trackFileName === 'string' && meta.trackFileName.trim() ? meta.trackFileName.trim() : (state.savedTrackInfo && state.savedTrackInfo.fileName) || null,
                duration: Number.isFinite(meta.trackDuration) ? meta.trackDuration : (state.savedTrackInfo && state.savedTrackInfo.duration) || null,
                beatDuration: Number.isFinite(meta.beatDuration) ? meta.beatDuration : (state.savedTrackInfo && state.savedTrackInfo.beatDuration) || null,
                totalBeats: Number.isFinite(meta.totalBeats) ? meta.totalBeats : (state.savedTrackInfo && state.savedTrackInfo.totalBeats) || null,
                gridStartBeat: Number.isFinite(meta.gridStartBeat) ? meta.gridStartBeat : (state.savedTrackInfo && state.savedTrackInfo.gridStartBeat) || null,
              };
            } else {
              const detectedFlag = hasBeats;
              state.pendingDetectionInfo = detectedFlag ? { method: 'auto-detect', confidence: null, source: 'detected' } : null;
              state.pendingIntroOffsetBeats = detectedFlag ? state.introOffsetBeats : null;
            }
            parseSettingsFromInputs();
            state.pendingImport = Array.isArray(phrases) ? phrases : null;
            state.pendingBeats = hasBeats ? beats : null;
            state.pendingAnchors = Array.isArray(anchors) && anchors.length > 0 ? anchors : null;

            if (Number.isFinite(audio.duration) && audio.duration > 0) {
              applyPendingTimingFromImport();
              buildGrid({ preserveExisting: false, skipStorage: true });
              if (state.pendingImport) {
                applyPhraseData(state.pendingImport);
                state.pendingImport = null;
              }
              queueSave();
            } else {
              window.alert('Import loaded. Load the matching audio track to rebuild the grid.');
            }
          } catch (err) {
            console.error('Failed to import JSON', err);
            window.alert('Import failed: invalid JSON structure.');
          } finally {
            importJsonInput.value = '';
          }
        };
        reader.onerror = () => {
          console.error('Failed to read file for import', reader.error);
          window.alert('Unable to read the selected file.');
          importJsonInput.value = '';
        };
        reader.readAsText(file);
      }

      function attachTimelineInteractions() {
        let dragging = false;

        function pointerToTime(event) {
          const rect = timeline.getBoundingClientRect();
          const ratio = rect.width > 0 ? (event.clientX - rect.left) / rect.width : 0;
          const clamped = Math.min(Math.max(ratio, 0), 1);
          return (audio.duration || 0) * clamped;
        }

        timeline.addEventListener('pointerdown', (event) => {
          if (!Number.isFinite(audio.duration) || audio.duration <= 0) return;
          dragging = true;
          timeline.setPointerCapture(event.pointerId);
          seekTo(pointerToTime(event));
        });

        timeline.addEventListener('pointermove', (event) => {
          if (!dragging) return;
          seekTo(pointerToTime(event));
        });

        const endDrag = (event) => {
          if (!dragging) return;
          dragging = false;
          try {
            timeline.releasePointerCapture(event.pointerId);
          } catch (err) {
            // ignore when pointer capture is not set
          }
        };

        timeline.addEventListener('pointerup', endDrag);
        timeline.addEventListener('pointercancel', endDrag);
        timeline.addEventListener('lostpointercapture', () => {
          dragging = false;
        });
      }

      function cleanupTrack() {
        if (state.objectUrl) {
          URL.revokeObjectURL(state.objectUrl);
          state.objectUrl = null;
        }
        audio.removeAttribute('src');
        audio.load();
        state.totalBeats = 0;
        state.gridBeatCount = 0;
        state.cellIndexMap.clear();
        state.phraseData = [];
        state.baseBeatTimes = null;
        state.finalBeatTimes = null;
        state.anchors = [];
        state.detectionInfo = { method: 'manual', confidence: null, source: 'manual' };
        state.analysisCache = null;
        state.pendingBeats = null;
        state.pendingAnchors = null;
        state.pendingDetectionInfo = null;
        state.pendingImport = null;
        state.waveformPeaks = null;
        state.waveformPeakCount = 0;
        state.waveformDuration = 0;
        state.waveformLoading = null;
        state.savedTrackInfo = null;
        state.pendingTrackFileName = null;
        state.pendingTrackDuration = null;
        state.introNotes = [];
        state.pendingIntroNotes = null;
        resetTapTempoHistory();
        gridBody.innerHTML = '';
        updateDetectionStatus();
        drawWaveform();
        if (timelineFill) timelineFill.style.width = '0';
        if (timelineCursor) timelineCursor.style.left = '0';
      }

      function handleTrackSelection(event) {
        const files = event.target.files;
        const file = files && files[0];
        if (!file) return;
        cleanupTrack();
        state.trackFileName = file.name;
        if (!trackLabelInput.value.trim()) {
          trackLabelInput.value = file.name.replace(/\.[^/.]+$/, '') || file.name;
        }
        updateTrackId();
        const objectUrl = URL.createObjectURL(file);
        state.objectUrl = objectUrl;
        audio.src = objectUrl;
        audio.load();
      }

      audio.addEventListener('loadedmetadata', () => {
        parseSettingsFromInputs();
        refreshWaveformPreview().catch(() => {
          // best effort: waveform preview not critical
        });
        const hadPendingTiming = Boolean(state.pendingBeats || state.pendingAnchors || state.pendingDetectionInfo);
        if (hadPendingTiming) {
          applyPendingTimingFromImport();
        }
        if (!Number.isFinite(state.beatDuration) || state.beatDuration <= 0) {
          window.alert('Please enter a valid BPM before building the grid.');
          return;
        }
        let skipStorage = hadPendingTiming;
        if (state.pendingImport) {
          state.phraseData = Array.isArray(state.pendingImport) ? state.pendingImport.map((row) => Array.isArray(row) ? row.slice(0, 8) : Array(8).fill('')) : [];
          state.pendingImport = null;
          skipStorage = true;
        }
        buildGrid({ preserveExisting: state.phraseData.length > 0, skipStorage });
        state.pendingTrackDuration = null;
        state.pendingTrackFileName = null;
      });

      audio.addEventListener('play', () => {
        if (state.clickTrackEnabled) {
          resumeAudioContext();
        }
      });

      audio.addEventListener('ended', () => {
        highlightBeat(state.totalBeats - 1);
      });

      playButton.addEventListener('click', () => {
        audio.play().catch((err) => {
          console.warn('Playback failed', err);
        });
      });

      pauseButton.addEventListener('click', () => {
        audio.pause();
      });

      backwardButton.addEventListener('click', () => {
        const step = state.beatDuration * 8;
        seekTo(audio.currentTime - step);
      });

      forwardButton.addEventListener('click', () => {
        const step = state.beatDuration * 8;
        seekTo(audio.currentTime + step);
      });

      autoDetectButton.addEventListener('click', () => {
        if (!hasAudioContext) {
          window.alert('Auto-detect requires Web Audio support in this browser.');
          return;
        }
        autoDetectBeatGrid();
      });

      tapTempoButton.addEventListener('click', handleTapTempo);
      anchorCurrentButton.addEventListener('click', anchorCurrentBeat);
      clearAnchorsButton.addEventListener('click', () => {
        if (!Array.isArray(state.baseBeatTimes) || state.baseBeatTimes.length === 0) {
          window.alert('There are no detected beats to clear anchors from yet.');
          return;
        }
        clearManualAnchors();
      });

      clickToggleButton.addEventListener('click', () => {
        if (!hasAudioContext) {
          window.alert('Click track requires Web Audio support in this browser.');
          return;
        }
        setClickTrackEnabled(!state.clickTrackEnabled);
      });

      rebuildButton.addEventListener('click', () => {
        parseSettingsFromInputs();
        if (!Number.isFinite(audio.duration) || audio.duration <= 0) {
          window.alert('Load an audio track before rebuilding the grid.');
          return;
        }
        buildGrid({ preserveExisting: false });
      });

      exportJsonButton.addEventListener('click', exportJson);
      exportCsvButton.addEventListener('click', exportCsv);
      importJsonButton.addEventListener('click', () => importJsonInput.click());
      importJsonInput.addEventListener('change', handleImportFile);

      trackFileInput.addEventListener('change', handleTrackSelection);
      trackLabelInput.addEventListener('input', () => {
        updateTrackId();
        queueSave();
      });

      bpmInput.addEventListener('change', () => {
        parseSettingsFromInputs();
        clearDetectedBeatMap();
        if (Number.isFinite(audio.duration) && audio.duration > 0) {
          buildGrid({ preserveExisting: false, skipStorage: true });
        }
      });

      offsetInput.addEventListener('change', () => {
        parseSettingsFromInputs();
        clearDetectedBeatMap();
        if (Number.isFinite(audio.duration) && audio.duration > 0) {
          buildGrid({ preserveExisting: false, skipStorage: true });
        }
      });

      introOffsetInput.addEventListener('change', () => {
        parseSettingsFromInputs();
        updateGridStartBeat(state.totalBeats);
        buildGrid({ preserveExisting: true, skipStorage: true });
        updateDetectionStatus();
        drawWaveform();
        queueSave();
      });

      gridBody.addEventListener('input', handleCellInput);
      gridBody.addEventListener('click', handleCellClick);
      gridBody.addEventListener('paste', handlePastePlainText);

      updateDetectionStatus();

      if (!hasAudioContext) {
        clickToggleButton.disabled = true;
        clickToggleButton.textContent = 'Click Track Unavailable';
        clickToggleButton.setAttribute('aria-pressed', 'false');
        clickToggleButton.classList.remove('active');
      } else {
        updateClickToggleButton();
      }

      attachTimelineInteractions();
      window.addEventListener('resize', drawWaveform);
      drawWaveform();

      if (!state.rafId) {
        state.rafId = window.requestAnimationFrame(playbackLoop);
      }

      window.addEventListener('beforeunload', () => {
        saveToStorage();
      });
    })();
  </script>
</body>
</html>
